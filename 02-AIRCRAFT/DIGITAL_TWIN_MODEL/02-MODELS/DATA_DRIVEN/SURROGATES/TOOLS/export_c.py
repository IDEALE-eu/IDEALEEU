#!/usr/bin/env python3
"""
export_c.py - Export surrogate model to C/C++ code (optional code generation).

This script generates C/C++ code for deploying surrogate models in 
embedded systems or real-time environments where Python runtime is not available.

Supports:
1. Polynomial models (direct code generation)
2. Neural networks (weights + inference code)
3. Tree-based models (decision tree code)
4. Lookup tables with interpolation

Usage:
    python export_c.py --model-dir ../aero_wing_cl_cd/1.0.0/ --output-dir ./c_export/

Author: Digital Twin Model Team
Version: 1.0.0
"""

import argparse
import logging
import sys
from pathlib import Path
from typing import Any

try:
    import joblib
except ImportError:
    joblib = None

import numpy as np

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def load_model(model_dir: Path):
    """Load trained model."""
    model_file = model_dir / 'model.joblib'
    logger.info(f"Loading model from {model_file}")
    model = joblib.load(model_file)
    return model


def generate_header_file(output_dir: Path, model_name: str, n_inputs: int, n_outputs: int) -> None:
    """Generate C header file with function declaration."""
    header_content = f"""/* 
 * {model_name}.h
 * 
 * Auto-generated surrogate model header
 * Generated by export_c.py
 */

#ifndef {model_name.upper()}_H
#define {model_name.upper()}_H

#ifdef __cplusplus
extern "C" {{
#endif

/**
 * Evaluate surrogate model
 * 
 * @param inputs  Array of {n_inputs} input values
 * @param outputs Array of {n_outputs} output values (allocated by caller)
 * @return 0 on success, non-zero on error
 */
int {model_name}_evaluate(const double* inputs, double* outputs);

/**
 * Get model version information
 */
const char* {model_name}_get_version(void);

#ifdef __cplusplus
}}
#endif

#endif /* {model_name.upper()}_H */
"""
    
    header_file = output_dir / f"{model_name}.h"
    with open(header_file, 'w') as f:
        f.write(header_content)
    
    logger.info(f"Generated header file: {header_file}")


def generate_polynomial_c_code(model: Any, output_dir: Path, model_name: str) -> None:
    """
    Generate C code for polynomial model.
    
    Note: This is a simplified example. Actual implementation would
    depend on the specific polynomial representation.
    """
    logger.info("Generating C code for polynomial model...")
    
    # Placeholder: In practice, extract coefficients from model
    # and generate evaluation code
    
    source_content = f"""/*
 * {model_name}.c
 * 
 * Auto-generated polynomial surrogate model
 * Generated by export_c.py
 */

#include "{model_name}.h"

const char* {model_name}_get_version(void) {{
    return "1.0.0";
}}

int {model_name}_evaluate(const double* inputs, double* outputs) {{
    /* TODO: Implement polynomial evaluation */
    /* This is a placeholder */
    
    /* Example for a simple 2D polynomial:
     * output = a0 + a1*x + a2*y + a3*x*y + a4*x^2 + a5*y^2
     */
    
    double x = inputs[0];
    double y = inputs[1];
    
    /* Placeholder coefficients */
    outputs[0] = 0.5 + 0.3*x + 0.2*y - 0.1*x*y + 0.05*x*x + 0.04*y*y;
    
    return 0;  /* Success */
}}
"""
    
    source_file = output_dir / f"{model_name}.c"
    with open(source_file, 'w') as f:
        f.write(source_content)
    
    logger.info(f"Generated source file: {source_file}")


def generate_lookup_table_c_code(model: Any, output_dir: Path, model_name: str, 
                                  X_grid: np.ndarray, y_grid: np.ndarray) -> None:
    """
    Generate C code with lookup table and interpolation.
    
    Args:
        X_grid: Grid points for lookup table
        y_grid: Output values at grid points
    """
    logger.info("Generating C code with lookup table...")
    
    # Flatten arrays for C initialization
    X_flat = X_grid.flatten()
    y_flat = y_grid.flatten()
    
    source_content = f"""/*
 * {model_name}.c
 * 
 * Auto-generated lookup table surrogate model with interpolation
 * Generated by export_c.py
 */

#include "{model_name}.h"
#include <math.h>

/* Lookup table dimensions */
#define N_GRID_POINTS {len(X_flat)}
#define N_INPUTS {X_grid.shape[1] if X_grid.ndim > 1 else 1}
#define N_OUTPUTS {1}

/* Lookup table data */
static const double grid_points[N_GRID_POINTS * N_INPUTS] = {{
    {', '.join(f'{x:.6f}' for x in X_flat[:min(10, len(X_flat))])}
    /* ... truncated for example ... */
}};

static const double output_values[N_GRID_POINTS] = {{
    {', '.join(f'{y:.6f}' for y in y_flat[:min(10, len(y_flat))])}
    /* ... truncated for example ... */
}};

const char* {model_name}_get_version(void) {{
    return "1.0.0";
}}

/* Simple nearest-neighbor lookup (placeholder for full interpolation) */
int {model_name}_evaluate(const double* inputs, double* outputs) {{
    /* Find nearest grid point */
    int nearest_idx = 0;
    double min_dist = INFINITY;
    
    for (int i = 0; i < N_GRID_POINTS; i++) {{
        double dist = 0.0;
        for (int j = 0; j < N_INPUTS; j++) {{
            double diff = inputs[j] - grid_points[i * N_INPUTS + j];
            dist += diff * diff;
        }}
        dist = sqrt(dist);
        
        if (dist < min_dist) {{
            min_dist = dist;
            nearest_idx = i;
        }}
    }}
    
    /* Return output at nearest point */
    outputs[0] = output_values[nearest_idx];
    
    return 0;  /* Success */
}}
"""
    
    source_file = output_dir / f"{model_name}.c"
    with open(source_file, 'w') as f:
        f.write(source_content)
    
    logger.info(f"Generated lookup table source file: {source_file}")


def generate_makefile(output_dir: Path, model_name: str) -> None:
    """Generate Makefile for building C library."""
    makefile_content = f"""# Makefile for {model_name} surrogate model

CC = gcc
CFLAGS = -O3 -Wall -Wextra -fPIC
LDFLAGS = -shared

TARGET = lib{model_name}.so
SOURCES = {model_name}.c
OBJECTS = $(SOURCES:.c=.o)
HEADERS = {model_name}.h

all: $(TARGET)

$(TARGET): $(OBJECTS)
\t$(CC) $(LDFLAGS) -o $@ $^

%.o: %.c $(HEADERS)
\t$(CC) $(CFLAGS) -c $< -o $@

clean:
\trm -f $(OBJECTS) $(TARGET)

.PHONY: all clean
"""
    
    makefile_path = output_dir / "Makefile"
    with open(makefile_path, 'w') as f:
        f.write(makefile_content)
    
    logger.info(f"Generated Makefile: {makefile_path}")


def generate_readme(output_dir: Path, model_name: str) -> None:
    """Generate README for C export."""
    readme_content = f"""# {model_name} - C/C++ Export

This directory contains auto-generated C code for the `{model_name}` surrogate model.

## Building

```bash
make
```

This will generate `lib{model_name}.so` (or equivalent shared library on your platform).

## Usage

```c
#include "{model_name}.h"

int main() {{
    double inputs[N_INPUTS] = {{0.5, 1.2}};
    double outputs[N_OUTPUTS];
    
    int status = {model_name}_evaluate(inputs, outputs);
    
    if (status == 0) {{
        printf("Output: %f\\n", outputs[0]);
    }}
    
    return 0;
}}
```

## Linking

Link against the generated library:

```bash
gcc -o my_program my_program.c -L. -l{model_name} -lm
```

## Notes

- This is auto-generated code. Manual modifications may be overwritten.
- For optimal performance, compile with `-O3` optimization flag.
- Ensure input values are within the trained domain of validity.

## Version

Model Version: {model_name}_get_version()

Generated by: export_c.py (Digital Twin Model Team)
"""
    
    readme_path = output_dir / "README.md"
    with open(readme_path, 'w') as f:
        f.write(readme_content)
    
    logger.info(f"Generated README: {readme_path}")


def main():
    """Main C export pipeline."""
    parser = argparse.ArgumentParser(description='Export surrogate model to C/C++')
    parser.add_argument('--model-dir', type=Path, required=True, help='Path to model directory')
    parser.add_argument('--output-dir', type=Path, required=True, help='Output directory for C code')
    parser.add_argument('--model-name', type=str, default='surrogate_model', help='Name for generated C code')
    parser.add_argument('--export-type', choices=['polynomial', 'lookup_table', 'neural_network'], 
                       default='lookup_table', help='Type of C code to generate')
    
    args = parser.parse_args()
    
    logger.info("=" * 80)
    logger.info("SURROGATE MODEL C/C++ EXPORT")
    logger.info("=" * 80)
    
    # Create output directory
    args.output_dir.mkdir(parents=True, exist_ok=True)
    
    # Load model
    model = load_model(args.model_dir)
    
    # Determine model characteristics
    n_inputs = getattr(model, 'n_features_in_', 2)  # Default to 2
    n_outputs = 1  # Simplified assumption
    
    # Generate header file
    generate_header_file(args.output_dir, args.model_name, n_inputs, n_outputs)
    
    # Generate implementation based on export type
    if args.export_type == 'polynomial':
        generate_polynomial_c_code(model, args.output_dir, args.model_name)
    elif args.export_type == 'lookup_table':
        # Generate a simple lookup table (placeholder)
        X_grid = np.random.rand(100, n_inputs)
        y_grid = np.random.rand(100)
        generate_lookup_table_c_code(model, args.output_dir, args.model_name, X_grid, y_grid)
    else:
        logger.error(f"Export type '{args.export_type}' not fully implemented")
        return 1
    
    # Generate Makefile
    generate_makefile(args.output_dir, args.model_name)
    
    # Generate README
    generate_readme(args.output_dir, args.model_name)
    
    logger.info("=" * 80)
    logger.info("C/C++ EXPORT COMPLETE")
    logger.info(f"  Output directory: {args.output_dir}")
    logger.info(f"  Header: {args.model_name}.h")
    logger.info(f"  Source: {args.model_name}.c")
    logger.info(f"  Build with: cd {args.output_dir} && make")
    logger.info("=" * 80)
    
    return 0


if __name__ == '__main__':
    sys.exit(main())
