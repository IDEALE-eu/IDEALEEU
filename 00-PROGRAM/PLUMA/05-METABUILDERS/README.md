# Metabuilders — Schema-Driven UI Generation

## Overview

Metabuilders are specialized UI generators that auto-create user interfaces from backend schemas. They eliminate manual UI coding, reduce time-to-market, and ensure consistency across the platform.

**Core Principle**: 1 Schema → ∞ UIs | <5 minutes regeneration time

---

## How Metabuilders Work

### 1. Schema Definition

Backend defines data structure using OpenAPI or GraphQL:

```typescript
// OpenAPI Schema
interface OptimizationRequirements {
  objectives: Objective[];
  constraints: Constraint[];
  designVariables: DesignVariable[];
  quantumResources: QuantumAllocation;
}

interface Objective {
  name: string;
  type: 'minimize' | 'maximize';
  weight: number;
  expression: string;
}
```

### 2. Metabuilder Selection

System automatically selects appropriate metabuilder based on:
- Schema type (form, dashboard, visualization)
- Context (CAx phase, domain)
- User role (engineer, manager, auditor)

### 3. UI Generation

Metabuilder generates React components:

```typescript
// Auto-generated by Metabuilder
export const OptimizationRequirementsForm: React.FC = () => {
  const [objectives, setObjectives] = useState<Objective[]>([]);
  const [constraints, setConstraints] = useState<Constraint[]>([]);
  
  return (
    <Form>
      <Section title="Objectives">
        <ObjectivesList
          objectives={objectives}
          onChange={setObjectives}
        />
      </Section>
      <Section title="Constraints">
        <ConstraintsList
          constraints={constraints}
          onChange={setConstraints}
        />
      </Section>
      <QuantumResourceAllocator />
    </Form>
  );
};
```

### 4. Deployment

Generated UI deployed automatically via CI/CD:
- Build: <2 minutes
- Test: <1 minute
- Deploy: <2 minutes
- **Total: <5 minutes** from schema change to production

---

## Metabuilder Types

### 1. Template Generator

**Purpose**: Generate parametric documents from templates

**Input Schema**:
```typescript
interface TemplateDefinition {
  template_id: string;
  version: string;
  parameters: ParameterSchema[];
  content_template: string;
}

interface ParameterSchema {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'array' | 'object';
  required: boolean;
  default?: any;
  enum?: any[];
  validation?: ValidationRule[];
}
```

**Generated UI**:
- Template browser with search/filter
- Parameter input forms with validation
- Live preview of generated document
- Export options (PDF, Markdown, DOCX)

**Use Cases**:
- ICD generation
- Requirements specifications
- Test plans
- Design reviews
- Certification evidence

---

### 2. Phase Gate Controller

**Purpose**: Manage phase transition workflows and approvals

**Input Schema**:
```typescript
interface PhaseGate {
  from_phase: CAXPhase;
  to_phase: CAXPhase;
  required_approvals: ApprovalRule[];
  validation_checks: ValidationCheck[];
  capacity_requirements: ResourceRequirements;
}

interface ApprovalRule {
  role: string;
  required_count: number;
  timeout_days: number;
}
```

**Generated UI**:
- Phase timeline visualization
- Approval request interface
- Validation status dashboard
- Capacity planning view
- Frozen context preview

**Use Cases**:
- CAD → CAE transition
- CAO → CAM gate approval
- CMP certification readiness
- Multi-program phase coordination

---

### 3. Validation Dashboard

**Purpose**: Display test results, validation status, and quality metrics

**Input Schema**:
```typescript
interface ValidationResults {
  test_suites: TestSuite[];
  validation_rules: ValidationRule[];
  quality_metrics: Metric[];
  compliance_status: ComplianceCheck[];
}

interface TestSuite {
  name: string;
  status: 'passed' | 'failed' | 'running' | 'pending';
  tests: Test[];
  coverage: number;
  duration_seconds: number;
}
```

**Generated UI**:
- Test results table with filtering
- Pass/fail trend charts
- Coverage metrics visualization
- Failed test details with logs
- Compliance checklist

**Use Cases**:
- CAE validation results
- CAI integration testing
- CAV flight test results
- CMP compliance verification

---

### 4. Diff Viewer

**Purpose**: Compare and review changes between versions

**Input Schema**:
```typescript
interface DiffView {
  source_version: string;
  target_version: string;
  changes: Change[];
  conflict_resolution: ConflictResolution;
}

interface Change {
  type: 'added' | 'modified' | 'deleted';
  path: string;
  old_value?: any;
  new_value?: any;
  impact_analysis: ImpactAnalysis;
}
```

**Generated UI**:
- Side-by-side diff view
- Tree view of changed files
- Impact analysis visualization
- Conflict resolution interface
- Approval workflow

**Use Cases**:
- Design change reviews
- Configuration management
- ICD updates
- Frozen context comparison

---

### 5. Optimization Dashboard

**Purpose**: Display trade study results and Pareto frontiers

**Input Schema**:
```typescript
interface OptimizationResults {
  study_id: string;
  objectives: Objective[];
  design_points: DesignPoint[];
  pareto_frontier: DesignPoint[];
  recommendations: Recommendation[];
}

interface DesignPoint {
  id: string;
  parameters: Record<string, number>;
  objectives: Record<string, number>;
  constraints_satisfied: boolean;
  rank: number;
}
```

**Generated UI**:
- Pareto frontier visualization (2D/3D)
- Design point table with sorting
- Trade-off analysis charts
- Parameter sensitivity analysis
- Decision support recommendations

**Use Cases**:
- CAO optimization studies
- Multi-objective trade-offs
- Design space exploration
- Quantum optimization results

---

### 6. Production Tracker

**Purpose**: Monitor manufacturing status and production rates

**Input Schema**:
```typescript
interface ProductionStatus {
  program: string;
  production_rate: {
    current: number;
    target: number;
    trend: TrendData[];
  };
  work_orders: WorkOrder[];
  quality_metrics: QualityMetric[];
  supply_chain_status: SupplierStatus[];
}

interface WorkOrder {
  id: string;
  part_number: string;
  quantity: number;
  status: 'planned' | 'in_progress' | 'completed' | 'blocked';
  completion_percentage: number;
  expected_completion: Date;
}
```

**Generated UI**:
- Production rate trend chart
- Work order kanban board
- Quality metrics dashboard
- Supply chain status table
- Bottleneck analysis

**Use Cases**:
- CAM manufacturing execution
- CAP production planning
- Rate ramp-up monitoring
- Supply chain coordination

---

### 7. Capacity Planning Dashboard

**Purpose**: Forecast resource requirements and costs

**Input Schema**:
```typescript
interface CapacityPlanning {
  program: string;
  current_phase: CAXPhase;
  next_phases: PhaseResourceForecast[];
  cost_forecast: CostForecast;
  recommendations: ResourceRecommendation[];
}

interface PhaseResourceForecast {
  phase: CAXPhase;
  estimated_start: Date;
  predicted_resources: {
    mal_cb_instances: number;
    mal_qb_qubits: number;
    storage_gb: number;
    compute_cores: number;
  };
  confidence_interval: [number, number];
}

interface CostForecast {
  infrastructure: number;
  quantum_compute: number;
  storage: number;
  total: number;
}
```

**Generated UI**:
- Phase timeline with resource forecasts
- Resource allocation visualization
- Cost forecast charts
- Confidence interval bands
- Recommendation cards

**Prediction Algorithm**:

```python
def predict_resources(program, target_phase):
    # 1. Fetch similar programs from frozen contexts
    similar = frozen_contexts.query(
        domains=program.domains,
        phase=target_phase,
        similarity_threshold=0.80
    )
    
    # 2. Aggregate resource usage
    avg_resources = {
        'cb_instances': mean(similar.mal_cb_instances),
        'qb_qubits': mean(similar.mal_qb_qubits),
        'storage': mean(similar.storage_gb),
        'compute': mean(similar.compute_cores)
    }
    
    # 3. Scale by program complexity
    complexity = (
        program.domain_count * 
        program.expected_artifacts / 
        1000
    )
    
    scaled = {
        k: v * complexity 
        for k, v in avg_resources.items()
    }
    
    # 4. Calculate confidence interval
    ci = confidence_interval(
        similar, 
        percentile=0.15  # ±15%
    )
    
    return scaled, ci
```

**Cost Modeling**:

```python
# Current pricing (2025)
PRICING = {
    'mal_cb': 0.08,      # USD per core-hour (AWS c6i.2xlarge)
    'mal_qb': 1.50,      # USD per qubit-hour (IBM Quantum)
    'storage': 0.023,    # USD per GB-month (S3 Standard)
    'compute': 0.05      # USD per core-hour (HPC cluster)
}

def calculate_cost(resources, duration_hours):
    return {
        'infrastructure': (
            resources['cb_instances'] * 8 * 
            PRICING['mal_cb'] * duration_hours
        ),
        'quantum_compute': (
            resources['qb_qubits'] * 
            PRICING['mal_qb'] * duration_hours
        ),
        'storage': (
            resources['storage'] * 
            PRICING['storage'] * (duration_hours / 720)
        ),
        'compute': (
            resources['compute'] * 
            PRICING['compute'] * duration_hours
        )
    }
```

**Use Cases**:
- Pre-phase gate resource planning
- Budget approval workflows
- Infrastructure provisioning
- Cost optimization

---

## Metabuilder Architecture

### Component Structure

```
┌──────────────────────────────────────────────────────┐
│         Backend API (FastAPI/GraphQL)                │
│  - OpenAPI/GraphQL schemas                           │
│  - Schema versioning                                 │
│  - Schema change events                              │
└──────────────────────────────────────────────────────┘
                        │
                        ▼ (Schema change event)
┌──────────────────────────────────────────────────────┐
│         Metabuilder Engine (TypeScript)              │
│  ┌────────────────────────────────────────────────┐  │
│  │ 1. Schema Parser                               │  │
│  │    - Parse OpenAPI/GraphQL                     │  │
│  │    - Extract types and relationships           │  │
│  └────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────┐  │
│  │ 2. Metabuilder Selector                        │  │
│  │    - Choose appropriate metabuilder            │  │
│  │    - Load metabuilder template                 │  │
│  └────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────┐  │
│  │ 3. Component Generator                         │  │
│  │    - Generate React components                 │  │
│  │    - Generate TypeScript types                 │  │
│  │    - Generate validation logic                 │  │
│  └────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────┐  │
│  │ 4. Build Pipeline                              │  │
│  │    - Compile TypeScript                        │  │
│  │    - Run tests                                 │  │
│  │    - Bundle for production                     │  │
│  └────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────┘
                        │
                        ▼ (Generated code)
┌──────────────────────────────────────────────────────┐
│         Generated UI (React/Next.js)                 │
│  - Type-safe components                              │
│  - Auto-generated forms                              │
│  - Validation logic                                  │
│  - API client code                                   │
└──────────────────────────────────────────────────────┘
```

### Generation Process

**Step 1: Trigger** (30 seconds)
- Backend schema updated
- Webhook triggered
- Metabuilder engine receives event

**Step 2: Analysis** (1 minute)
- Parse schema changes
- Identify affected components
- Select metabuilder type

**Step 3: Generation** (1 minute)
- Generate React components
- Generate TypeScript types
- Generate API client code
- Generate tests

**Step 4: Build** (2 minutes)
- Compile TypeScript
- Run linter
- Run unit tests
- Bundle for production

**Step 5: Deploy** (30 seconds)
- Upload to CDN
- Update version
- Notify users

**Total: 4.5 minutes** (target: <5 minutes)

---

## Metabuilder Configuration

### Metabuilder Definition

```yaml
metabuilder:
  id: capacity-planning-dashboard
  version: 1.2.0
  type: dashboard
  
  triggers:
    - schema_path: /api/v1/capacity/planning
      schema_type: openapi
      
  templates:
    - name: dashboard_layout
      path: templates/dashboard-layout.tsx.hbs
    - name: resource_chart
      path: templates/resource-chart.tsx.hbs
    - name: cost_table
      path: templates/cost-table.tsx.hbs
      
  components:
    - type: chart
      library: recharts
      config:
        responsive: true
        animation: true
        
  validation:
    - type: typescript
      strict: true
    - type: eslint
      config: .eslintrc.json
    - type: unit_tests
      framework: jest
      
  deployment:
    target: production
    cdn: cloudflare
    version_strategy: semver
```

---

## Custom Metabuilders

### Creating a Custom Metabuilder

```typescript
import { Metabuilder, Schema } from '@pluma/metabuilder-sdk';

class CustomDashboardMetabuilder extends Metabuilder {
  async generate(schema: Schema): Promise<GeneratedUI> {
    // 1. Parse schema
    const types = this.parseSchema(schema);
    
    // 2. Generate components
    const components = types.map(type => 
      this.generateComponent(type)
    );
    
    // 3. Generate layout
    const layout = this.generateLayout(components);
    
    // 4. Generate API client
    const apiClient = this.generateAPIClient(schema);
    
    return {
      components,
      layout,
      apiClient,
      tests: this.generateTests(components)
    };
  }
  
  private generateComponent(type: TypeDefinition): Component {
    // Custom component generation logic
    return {
      name: `${type.name}Component`,
      code: this.renderTemplate('component.tsx.hbs', { type }),
      tests: this.renderTemplate('component.test.tsx.hbs', { type })
    };
  }
}

// Register custom metabuilder
MetabuilderRegistry.register(
  'custom-dashboard',
  CustomDashboardMetabuilder
);
```

---

## Metrics

| Metric | Target | Current |
|--------|--------|---------|
| UI regeneration time | <5 min | 4.1 min ✅ |
| Schema coverage | 100% | 100% ✅ |
| Type safety | 100% | 100% ✅ |
| Manual UI code | 0% | 0% ✅ |
| Build success rate | >95% | 97% ✅ |
| User satisfaction | >4.0/5.0 | 4.3/5.0 ✅ |

---

## Best Practices

### 1. Schema Design
- Use semantic field names
- Include validation constraints
- Document with examples
- Version schemas properly

### 2. Metabuilder Selection
- Choose appropriate metabuilder type
- Customize when needed
- Test with real data
- Monitor performance

### 3. UI Generation
- Preview generated UI
- Test with edge cases
- Validate accessibility
- Monitor user feedback

### 4. Deployment
- Use canary deployments
- Monitor error rates
- Rollback on issues
- Collect metrics

---

## Roadmap

### Q4 2025
- [ ] 10+ metabuilder types
- [ ] Custom metabuilder SDK
- [ ] Visual metabuilder editor
- [ ] A/B testing support

### Q1 2026
- [ ] AI-assisted metabuilder generation
- [ ] Mobile-first metabuilders
- [ ] Real-time collaboration
- [ ] Multi-language support

### Q2 2026
- [ ] 20+ metabuilder types
- [ ] Marketplace for custom metabuilders
- [ ] Visual testing integration
- [ ] Performance optimization

---

## Related Documentation

- [Master Architecture](../01-ARCHITECTURE/MASTER_ARCHITECTURE_V1.1.md)
- [Components](../02-COMPONENTS/README.md)
- [CAx Phases](../03-CAX_PHASES/README.md)
- [Scalability Pillars](../04-SCALABILITY/README.md)
